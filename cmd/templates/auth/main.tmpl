package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"
	"time" // For context timeout, if needed in shutdown

	"github.com/gofiber/fiber/v2"
	"github.com/joho/godotenv"

	// Import your global middleware package from the monorepo root
	"pkg/http"
	// Import the internal package for the auth service components
	internal "{{.Name | lower}}-service/internal"
)

func main() {
	// Load environment variables from .env file
	// This will typically contain JWT_SECRET and API_KEY for your middlewares
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found or failed to load. Using system environment variables.")
	}

	// --- Service & Controller Wiring ---
	// Instantiate your authentication service
	// In a real application, you might pass a database connection here: internal.NewAuthService(db)
	authService := internal.NewAuthService()
	// Instantiate your authentication controller, injecting the service
	authController := internal.NewAuthController(authService)

	// --- Fiber App Setup ---
	// Initialize a new Fiber application instance
	app := fiber.New()

	// Apply global Fiber middlewares defined in your shared pkg/http/middleware
	// This includes logging, CORS, recovery, security headers, etc.
	middleware.InitGlobalMiddlewares(app)

	// Register all authentication-related routes with the Fiber application
	// This will set up your login and other auth endpoints.
	internal.RegisterAuthRoutes(app, authController)

	// Set application port. This will be {{.Port}} as assigned by the CLI.
	port := os.Getenv("PORT")
	if port == "" {
		port = "{{.Port}}" // Default port for auth service, generated by CLI
	}

	// --- Start HTTP Server in a Goroutine ---
	go func() {
		log.Printf("Auth service is running on :%s", port)
		if err := app.Listen(":" + port); err != nil && err != fiber.ErrServerClosed {
			// Log fatal error if server fails to start or closes unexpectedly
			log.Fatalf("Fiber Listen error: %v", err)
		}
	}()

	// --- Graceful Shutdown ---
	// Create a channel to listen for OS signals (e.g., Ctrl+C, SIGTERM from Docker/Kubernetes)
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// Block until a termination signal is received
	<-quit
	log.Println("Shutdown signal received, shutting down gracefully...")

	// Attempt to gracefully shut down the Fiber app.
	// We use a context with a timeout to ensure shutdown doesn't hang indefinitely.
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) // 5-second timeout
	defer cancel()

	if err := app.ShutdownWithContext(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server gracefully stopped.")
}